require utils.mj
require gates.mj
require flags.mj

add(r:[reg_addr], d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  (R, c) = adder<word>(Rd, Rr, 0);

  S7 = S[7];
  S6 = S[6];
  S5 = cH(R[3], Rd[3], Rr[3]);
  S3 = cV(R[7], Rd[7], Rr[7]);
  S4 = cS(S2, S3);
  S2 = R[7];
  S1 = cZ(R);
  S0 = cC(R[7], Rd[7], Rr[7]);

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

adc(r:[reg_addr], d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  c = getC(S);
  (R, c) = adder<word>(Rd, Rr, c);

  S7 = S[7];
  S6 = S[6];
  S5 = cH(R[3], Rd[3], Rr[3]);	# H
  S4 = cS(S2, S3);	# S
  S3 = cV(R[7], Rd[7], Rr[7]); # V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = cC(R[7], Rd[7], Rr[7]);	# C

  S = setStatus(S[0-7]);

  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;

end where

and_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (a[0] and b[0]) . (and_n<n-1>(a[1..], b[1..]))
  end if
end where

and_op(d:[reg_addr], r:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  R = and_n<word>(Rd, Rr);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5] ;			# H
  S3 = 0;			# V
  S4 = cS(S2, S3);
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0]; 			# C

  S = setStatus(S[0-7]);

  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

andi(d:[reg_addr], K:[word], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);

  R = and_n<word>(Rd, K);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5]; 			# H
  S3 = 0;			# V
  S4 = cS(S2, S3);
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0];			# C

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

or_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    a0 = a[0];
    b0 = b[0];
    o = (a0 or b0) . (or_n<n-1>(a[1..], b[1..]))
  end if
end where

or_op(d:[reg_addr], r:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  R = or_n<word>(Rd, Rr);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5]; 			# H
  S4 = cS(S2, S3);		# S
  S3 = 0;			# V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0];

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

ori(d:[reg_addr], K:[word], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);

  R = or_n<word>(Rd, K);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5];
  S4 = cS(S2, S3);		# S
  S3 = 0;			# V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0];

  S = setStatus(S[0-7]);

  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

xor_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o=[]
  else
    a0 = a[0];
    b0 = b[0];
    o = (a0 xor b0) . xor_n<n-1>(a[1..], b[1..])
  end if
end where

eor(d:[reg_addr], r:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  R = xor_n<word>(Rd, Rr);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5];			# H
  S4 = cS(S2, S3);		# S
  S3 = 0;			# V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0];			# C

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

com_n<n>(a:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (a[0] & 0).com_n<n-1>(a[1..])
  end if
end where

com(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  R = com_n<word>(Rd);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5];
  S4 = cS(S2, S3);		# S
  S3 = 0;			# V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = 1;			# C

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where					

sbr(d:[reg_addr], K:[word], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  (regs[16-31], S, PC, SP) = ori(d, K, regs[16-31], S, PC, SP)
end where

cbr(d:[reg_addr], K:[word], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  a = com_n<word>(K);
  (regs[16-31], S, PC, SP) = andi(d, a, regs[16-31], S, PC, SP)
end where

inc(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  o = one<word>();

  R = increase<word>(R);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5];
  S4 = cS(S2, S3);		# S
  S3 = cV2(R);			# V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0];			# C

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

tst(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  R = and_n<word>(Rd, Rd);

  S7 = S[7];
  S6 = S[6];
  S5 = S[5];
  S4 = cS(S2, S3);		# S
  S3 = 0;			# V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = S[0]; 			# C

  S = setStatus(S[0-7]);
  (regs[16-31], S, PC, SP) = and_op(d, d, regs[16-31], S, PC, SP)

end where

clr(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  S7 = S[7]; 			# I
  S6 = S[6];			# T
  S5 = S[5];			# H
  S4 = 0;			# S
  S3 = 0;			# V
  S2 = 0;			# N
  S1 = 1;			# Z
  S0 = S[0]; 			# C

  S = setStatus(S[0-7]);
  (regs[16-31], S, PC, SP) = eor(d, d, regs[16-31], S, PC, SP)
end where

ser(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  o = allone<word>();
  
  (regs[16-31]) = push_register(d, o, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
  S = S;
end where

sub(r:[reg_addr], d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  (R, c) = subtracter<word>(Rd, Rr);

  S7 = S[7];
  S6 = S[6];
  S5 = cH(not R[3], not Rd[3], Rr[3]);	# H
  S4 = cS(S2, S3);		# S
  S3 = cV(R[7], Rd[7], not Rr[7]); # V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = cC(not R[7], not Rd[7], Rr[7]); # C

  S = setStatus(S[0-7]);

  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

subi(d:[4], K:[8], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(1.d, regs[16-31]);
  
  (R, c) = subtracter<word>(Rd, K);

  S7 = S[7];			# I
  S6 = S[6];			# T
  S5 = cH(not R[3], not Rd[3], K[3]);	# H
  S4 = cS(S2, S3);		# S
  S3 = cV(R[7], Rd[7], not K[7]); # V
  S2 = R[7];			# N
  S1 = cZ(R);			# Z
  S0 = cC(not R[7], not Rd[7], K[7]); # C

  S = setStatus(S[0-7]);
  
  (regs[16-31]) = push_register(1.d, R, regs[16-31]);
  
  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

sbc(d:[4], K:[8], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where # TODO
  (regs[16-31]) = regs_identity(regs[16-31]);
  S = S;
  PC = PC;
  SP = SP
end where

sbci(d:[4], K:[8], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where # TODO
  (regs[16-31]) = regs_identity(regs[16-31]);
  S = S;
  PC = PC;
  SP = SP
end where

neg(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  zero = zero<word>();

  (R, c) = subtracter<word>(zero, Rd);

  S7 = S[7];			# I
  S6 = S[6];			# T
  S5 = R[3] or Rd[3];		# H
  S4 = cS(S2, S3);      		# S
  S3 = cV2(R);			# V
  S2 = R[7]; 			# N
  S1 = cZ(R);			# Z
  S0 = R[7] or R[6] or R[5] or R[4] or R[3] or R[2] or R[1] or R[0]; # C

  S = setStatus(S[0-7]);
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where

dec(d:[reg_addr], regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) = (regs[16-31]:[word], S:[word], PC:[word+word], SP:[word+word]) where
  Rd = pop_register(d, regs[16-31]);
  one = one<word>();

  (R, c) = subtracter<word>(one, Rd);
  
  S7 = S[7];
  S6 = S[6];
  S5 = S[5];
  S4 = cS(S2, S3);      		# S
  S3 = cV3(R);			# V
  S2 = R[7]; 			# N
  S1 = cZ(R);			# Z
  S0 = S[0];

  S = setStatus(S[0-7]);
  (regs[16-31]) = push_register(d, R, regs[16-31]);

  PC = increase<ram_addr_size>(PC);
  SP = SP;
end where
