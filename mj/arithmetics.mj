require utils.mj
require gates.mj

adder<n>(a:[n], b:[n], c_in) = (o:[n], c_out) where
  if n = 0 then
    o = [];
    c_out = 0
  else
    (s_n1, c_n1) = adder<n-1>(a[1..], b[1..], c_in);
    (s_n, c_out) = fulladder(a[0], b[0], c_n1)
    o = s_n . s_n1
  end if
end where

subtracter<n>(a:[n], b:[n]) = (o:[n], c_out) where
  # b-a
  an = not(a)
  (o, c) = adder<n>(an, b, 1)
  c_out = c & 1
end where
  

add(r:[reg_addr], d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  (Rd, regs[0-31]) = pop_register(d, regs[0-31])
  (Rr, regs[0-31]) = pop_register(r, regs[0-31])

  (R, c) = adder<word>(Rd, Rr, 0)

  set_carry(c)
  set_zero(R)
  n = set_negative(R)
  v = set_overflow(Rd, Rr, R)
  set_sign(n, v)
  set_half_carry(Rd, Rr, R)

  (regs[0-31]) = push_register(d, R)
end where

adc(r:[reg_addr], d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  Rr = pop_register(r, regs[0-31])

  c = get_carry()
  (R, c) = adder<word>(Rd, Rr, c)

  set_carry(c)
  set_zero(R)
  n = set_negative(R)
  v = set_overflow(Rd, Rr, R)
  set_sign(n, v)
  set_half_carry(Rd, Rr, R)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

and_n<n>(a:[n], b:[n])=(o:[n]) where
  if n = 0 then
    o = []
  else
    o = (a[0] and b[0]) . (and_n<n-1>(a[1..],b[1..]))
  end if
end where

and(d:[reg_addr], r:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  Rr = pop_register(r, regs[0-31])

  R = and_n<word>(Rd, Rr)

  set_zero(R)
  n = set_negative(R)
  v = set_overflow(Rd, Rr, R)
  set_sign(n,v)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

andi(d:[reg_addr], K:[word], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])

  R = and_n<word>(Rd, K)

  set_zero(R)
  n = set_negative(R)
  v = set_overflow(Rd, Rr, R)
  set_sign(n,v)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

or_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (a[0] or b[0]) . (or_n<n-1>(a[1..], b[1..]))
  end if
end where

or(d:[reg_addr], r:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  Rr = pop_register(r, regs[0-31])

  R = or_n(Rd, Rr)

  set_zero(R)
  n = set_negative(R)
  v = 0
  set_sign(n,v)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

ori(d:[reg_addr], K:[word], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])

  R = or_n(Rd, K)

  set_zero(R)
  n = set_negative(R)
  v = 0
  set_sign(n, v)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

xor_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o=[]
  else
    o = (a[0] xor b[0]). xor_n<n-1>(a[1..], b[1..])
  end if
end where

eor(d:[reg_addr], r:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  Rr = pop_register(r, regs[0-31])

  R = xor_n<word>(Rd, Rr)

  n = set_negative(R)
  v = set_overflow(Rd, Rr, R)
  s = set_sign(n,v)
  set_zero(R)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

com_n<n>(a:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    if a[0] = 0 then
      o = 1.com_n<n-1>(a[1..])
    else
      o = 0.com_n<n-1>(a[1..])
    end if
  end if
end where

com(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  R = com_n<word>(Rd)

  set_carry(1)
  v = 0
  n = set_negative(R)
  set_zero(R)
  s = set_sign(n,v)

  push_register(d, R, regs[0-31])
end where					

sbr(d:[reg_addr], K:[word], regs[0-31]) = (regs[0-31]) where
  regs[0-31] = ori(d, K)
end where

cbr(d:[reg_addr], K:[word]) = () where
  a = com_n<word>(K)
  regs[0-31] = andi(d,a)
end where

inc(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  o = one<word>

  (R,c) = adder(Rd, o, 0)

  n = set_negative(R)
  v = set_overflow(R)
  s = set_sign(n, v)
  set_zero(R)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

tst(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  regs[0-31] = and(d, d)
end where

clr(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  regs[0-31] = eor(d, d)
end where

ser(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  o = allone<word>
  regs[0-31] = push_register(d, o, regs[0-31])
end where

sub(r:[reg_addr], d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  Rr = pop_register(r, regs[0-31])

  (R, c) = subtracter<word>(Rd, Rr, 0)

  carry = (not(Rd[7]) and Rr[7]) or (Rr[7] and R[7]) or (R[7] and Rd[7])
  
  set_carry(carry)
  set_zero(R)
  n = set_negative(R)
  v = set_overflow(Rd, Rr, R)
  set_sign(n, v)
  set_half_carry(Rd, Rr, R)

  regs[0-31] = push_register(d, R, regs[0-31])
end where

subi(d:[4], K[8], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])

  (R, c) = subtracter<word>(Rd, K, 0)

  regs[0-31] = push_register(d, R, regs[0-31])
  
end where

sbc() = () where # TODO
end where

sbci() = () where # TODO
end where

neg(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  zero = zero<word>

  (R, c) = subtracter(zero, Rd, 0)

  set_carry(1)
  v = 0
  n = set_negative(R)
  set_zero(R)
  s = set_sign(n,v)

  regs[0-31] = push_register(d, R, regs[0-31])

end where

dec(d:[reg_addr], regs[0-31]) = (regs[0-31]) where
  Rd = pop_register(d, regs[0-31])
  one = one<word>

  (R, c) = subtracter(one, Rd, 0)

  # TODO â†“
  set_V(V)
  N = set_negative(R)
  set_zero(R)
  set_sign(N,V)

  regs[0-31] = push_register(d, R, regs[0-31])
end where
