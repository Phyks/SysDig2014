require utils.mj
require gates.mj
require flags.mj

adder<n>(a:[n], b:[n], c_in) = (o:[n], c_out) where
  if n = 0 then
    o = [];
    c_out = 0
  else
    (s_n1, c_n1) = adder<n-1>(a[1..], b[1..], c_in);
    (s_n, c_out) = fulladder(a[0], b[0], c_n1);
    o = s_n . s_n1
  end if
end where

subtracter<n>(a:[n], b:[n]) = (o:[n], c_out) where
  # b-a
  an = not(a) ;
  (o, c) = adder<n>(an, b, 1) ;
  c_out = c and 1
end where
  

add(r:[reg_addr], d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  (R, c) = adder<word>(Rd, Rr, 0);

  S0 = S[0];
  S1 = S[1];
  S2 = cH(R[3], Rd[3], Rr[3]);
  S3 = cS(N, V);
  S4 = cV(R[7], Rd[7], Rr[7]);
  S5 = R7;
  S6 = cZ(R);
  S7 = cC(R[7], Rd[7], Rr[7]);

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R)
end where

adc(r:[reg_addr], d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  c = getC(S);
  (R, c) = adder<word>(Rd, Rr, c);

  S0 = S[0];
  S1 = S[1];
  S2 = cH(R[3], Rd[3], Rr[3]);	# H
  S3 = cS(N, V)	;	# S
  S4 = cV(R[7], Rd[7], Rr[7]); # V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = cC(R[7], Rd[7], Rr[7]);	# C

  S = setStatus(S[0-7], S);

  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

and_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (a[0] and b[0]) . (and_n<n-1>(a[1..], b[1..]))
  end if
end where

and_op(d:[reg_addr], r:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  R = and_n<word>(Rd, Rr);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2] ;			# H
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7]; 			# C

  S = setStatus(S[0-7], S);

  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

andi(d:[reg_addr], K:[word], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);

  R = and_n<word>(Rd, K);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2]; 			# H
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7];			# C

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

or_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    a0 = a[0];
    b0 = b[0];
    o = (a0 or b0) . (or_n<n-1>(a[1..], b[1..]))
  end if
end where

or_op(d:[reg_addr], r:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2]; 			# H
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7];

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

ori(d:[reg_addr], K:[word], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);

  R = or_n(Rd, K);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2];
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7];

  S = setStatus(S[0-7], S);

  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

xor_n<n>(a:[n], b:[n]) = (o:[n]) where
  if n = 0 then
    o=[]
  else
    a0 = a[0];
    b0 = b[0];
    o = (a0 xor b0) . xor_n<n-1>(a[1..], b[1..])
  end if
end where

eor(d:[reg_addr], r:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  R = xor_n<word>(Rd, Rr);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2];			# H
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7];			# C

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

com_n<n>(a:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (a[0] & 0).com_n<n-1>(a[1..])
  end if
end where

com(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  R = com_n<word>(Rd);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2];
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = 1;			# C

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R, regs[16-31])
end where					

sbr(d:[reg_addr], K:[word], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  (regs[16-31], S:[word]) = ori(d, K, regs[16-31], S)
end where

cbr(d:[reg_addr], K:[word], S:[word]) = (S:[word]) where
  a = com_n<word>(K);
  (regs[16-31], S) = andi(d, a, regs[16-31], S)
end where

inc(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  o = one<word>();

  (R,c) = adder(Rd, o, 0);

  S0 = S[0];
  S1 = S[1];
  S2 = S[2];
  S3 = cS(N, V);		# S
  S4 = cV2(R);			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7];			# C

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

tst(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  S0 = S[0];
  S1 = S[1];
  S2 = S[2];
  S3 = cS(N, V);		# S
  S4 = 0;			# V
  S5 = R7;			# N
  S6 = cZ(R);			# Z
  S7 = S[7]; 			# C

  S = setStatus(S[0-7], S);
  regs[16-31], S = and_op(d, d, regs[16-31], S)
end where

clr(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  S0 = S[0]; 			# I
  S1 = S[1];			# T
  S2 = S[2];			# H
  S3 = 0;			# S
  S4 = 0;			# V
  S5 = 0;			# N
  S6 = 1;			# Z
  S7 = S[7]; 			# C

  S = setStatus(S[0-7], S);
  (regs[16-31]) = eor(d, d)
end where

ser(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  o = allone<word>();
  
  (regs[16-31]) = push_register(d, o, regs[16-31])
end where

sub(r:[reg_addr], d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  Rr = pop_register(r, regs[16-31]);

  (R, c) = subtracter<word>(Rd, Rr, 0);

  S0 = S[0];
  S1 = S[1];
  S2 = cH(not R[3], not Rd[3], Rr[3]);	# H
  S3 = cS(S, V);		# S
  S4 = cV(R[7], Rd[7], not Rr[7]); # V
  S5 = R[7];			# N
  S6 = cZ(R);			# Z
  S7 = cC(cH(not R[7], not Rd[7], Rr[7])); # C

  S = setStatus(S[0-7], S);

  (regs[16-31]) = push_register(d, R, regs[16-31])
end where

subi(d:[4], K[8], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);

  (R, c) = subtracter<word>(Rd, K, 0);

  S0 = S[0];			# I
  S1 = S[1];			# T
  S2 = cH(not R[3], not Rd[3], Rr[3]);	# H
  S3 = cS(S, V);		# S
  S4 = cV(R[7], Rd[7], not Rr[7]); # V
  S5 = R[7];			# N
  S6 = cZ(R);			# Z
  S7 = cC(cH(not R[7], not Rd[7], Rr[7])); # C

  S = setStatus(S[0-7], S);
  
  (regs[16-31]) = push_register(d, R, regs[16-31])
  
end where

sbc() = () where # TODO
end where

sbci() = () where # TODO
end where

neg(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  zero = zero<word>();

  (R, c) = subtracter(zero, Rd, 0);

  S0 = S[0];			# I
  S1 = S[1];			# T
  S2 = R[3] or Rd[3];		# H
  S3 = cS(N, V);      		# S
  S4 = cV2(R);			# V
  S5 = R[7]; 			# N
  S6 = cZ(R);			# Z
  S7 = R[7] or R[6] or R[5] or R[4] or R[3] or R[2] or R[1] or R[0]; # C

  S = setStatus(S[0-7], S);
  (regs[16-31]) = push_register(d, R, regs[16-31])

end where

dec(d:[reg_addr], regs[16-31], S:[word]) = (regs[16-31], S:[word]) where
  Rd = pop_register(d, regs[16-31]);
  one = one<word>();

  (R, c) = subtracter(one, Rd, 0);
  
  S0 = S[0];
  S1 = S[1];
  S2 = S[2];
  S3 = cS(N, V);      		# S
  S4 = cV3(R);			# V
  S5 = R[7]; 			# N
  S6 = cZ(R);			# Z
  S7 = S[7];

  S = setStatus(S[0-7], S);
  (regs[16-31]) = push_register(d, R, regs[16-31])
end where
